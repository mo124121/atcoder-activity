#!/usr/bin/env python3
import sys

sys.setrecursionlimit(10**6)
NO = "Ambiguous"


class WeightedUnionFind:
    def __init__(self, N):
        N += 1
        self.par = [-1] * N
        self.diff_weight = [0] * N  # 根からの重み

    def root(self, x):
        q = []
        while self.par[x] >= 0:
            q.append(x)
            x = self.par[x]
        for i in reversed(q):
            self.diff_weight[i] += self.diff_weight[self.par[i]]
            self.par[i] = x

        return x

    def weight(self, x):
        self.root(x)
        return self.diff_weight[x]

    def diff(self, x, y):
        return self.weight(y) - self.weight(x)

    def same(self, x, y):
        return self.root(x) == self.root(y)

    def unite(self, x, y, w):
        x_root = self.root(x)
        y_root = self.root(y)
        w += self.diff_weight[x] - self.diff_weight[y]
        x, y = x_root, y_root
        if x == y:
            return
        if self.par[y] < self.par[x]:
            x, y, w = y, x, -w
        self.par[x] += self.par[y]
        self.par[y] = x
        self.diff_weight[y] = w


def solve(
    N: int, Q: int, T: "List[int]", X: "List[int]", Y: "List[int]", V: "List[int]"
):
    wuf = WeightedUnionFind(N)
    ret = []
    for i in range(Q):
        t, x, y, v = T[i], X[i] - 1, Y[i] - 1, V[i]
        if t:
            if wuf.same(x, y):
                r = wuf.diff(y, x)
                if x % 2 == 0:
                    r -= v
                else:
                    r += v
                if y % 2 == 0:
                    r *= -1
                ret.append(r)
            else:
                ret.append(NO)
        else:
            if x % 2 == 0:
                wuf.unite(y, x, v)
            else:
                wuf.unite(y, x, -v)

    print(*ret, sep="\n")
    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    T = [int()] * (Q)  # type: "List[int]"
    X = [int()] * (Q)  # type: "List[int]"
    Y = [int()] * (Q)  # type: "List[int]"
    V = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        T[i] = int(next(tokens))
        X[i] = int(next(tokens))
        Y[i] = int(next(tokens))
        V[i] = int(next(tokens))
    solve(N, Q, T, X, Y, V)


if __name__ == "__main__":
    main()


"""
UFっぽい
ペアとして和が定義されていれば、片方の値が定まればもう片方は固まる
UFでつながっていれば同じ
UFで同じならambiguiousかどうかは判定ができる

問題は数値をどう出すか？
N<10**5なので
N**2となるようなパターンを全て保持するのは現実的じゃない

要は区間和なので、fenwickで出す

まとめ
・Ambiguious判断->Union Find
・クエリ回答->fenwick

A4=V3-A3
A5=V4-A4=V4-V3+A3
A6=V5-A5=V5-(V4-A4)=V5-V4+A4=V5-V4+V3-A3

S34=V3-V4
A5=-(S34-A3)
  =-S34+A3

S35=V3-V4+V5
A6=S35-A3

A5=V4-A4
A6=V5-A5=V5-V4+A4
A7=V6-A6=V6-(V5-A5)=V6-V5+A5=V6-V5+V4-A4

S45=-V4+V5
A6=S45+A4

S46=-V4+V5-V6
A7=-S46-A4

in_1
V:3 6 6 ? ? ?



S1=V1
S2=V1-V2
S3=V1-V2+V3
S4=V1-V2+V3-V4

3->4:A4=V3-A3=s3-s2+a3
3->5:A5=V4-a4=v4-v3+a3=-(s4-s2)+a3

2->3:a3=v2-a2=-(s2-s1)-A2
2->4:a4=v3-a3=v3-v2+a2=s3-s1+a2=-(-(s3-s1)-a2)

"""
