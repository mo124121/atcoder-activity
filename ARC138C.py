from heapq import heapify, heappop


N = int(input())
A = list(map(int, input().split()))
X = [(A[i], i) for i in range(N)]
X.sort()
B = [1] * N
s = 0
for i in range(N // 2, N):
    a, j = X[i]
    B[j] = -1
    s += a

C = [0] * (N + 1)

for i in range(N):
    C[i + 1] = C[i] + B[i]

k = C.index(min(C)) - C[0]


print(k, s)
"""
考察
N<2*10**5
O(NlogN)あたりまで

なんかmultisetくさいんだよなあ

とりあえず、1回の勝負で最適なものは
heapで最高のスコアのをとりつつ、最小の番号を都度記憶して、記憶されているときは飛ばす感じにする
感じでシミュレートできる
これが違うかも、太郎君がとるのと次にとるのを比較して、
悪化するなら取りに行く・・・のか？
そもそも後半にめっちゃいいのが来るならわざわざとる必要なくない？


シフトすることでなるべく後半に大きな数字が書かれている状態にしたい

いったんシミュレートしてみる
シミュレーション自体が複雑ではある
・とにかくその都度最大のをとる　→　0番目に2位がいたらアウト
・とらせると損する場合はとる　具体的には
  ・太郎のターゲット・時点ターゲットと比較して次点ターゲットのほうが低かったらとる
    →　そもそもとる必要がないものをとる形になる
  ・上位半分をとることを目指す、それをとられる時、次点ターゲットをとられると悪化する時を除きとる
    避けられない場合は次善のものを目指す範囲にいれる

二つの基準に基づいて取り合う
別に右に寄せずとも、左から交互にいいものがくればそれでいい
合計値で考えちゃいけない

一方で交互性は保証されない、

1つ動かすケースと2つ動かすケースを考える


解説後
上界が達成可能

"""
