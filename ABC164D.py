S = input()

MOD = 2019
occ = [0] * 2019
occ[0] = 0
ret = 0
n = 0
for i, c in enumerate(S):
    occ_n = [0] * 2019
    c = int(c)
    for j in range(2019):
        occ_n[(j * 10 + c) % MOD] += occ[j]
    occ_n[c] += 1
    ret += occ_n[0]
    occ = occ_n

print(ret)


"""
でっかい数字をどう扱うか問題

上のほうからおろしていったらいいのでは？
整数の組みとな
N=len(S)<2*10**5

愚直にチェックしたらN**2

鳥の巣っぽい
ある数字を10倍するとどういう世界になるか？
10000倍のほうが都合がいい？

10倍してずらす行為をしていく時にどういうmodが出てきたかカウントする

たぶんしたから数えたほうがいい

10倍するとmod空間自体がズレる、これを使えないか
N*2019= 5*10**8 間に合うのか？

"""
