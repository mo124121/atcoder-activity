N = int(input())


def order_count(n):
    return len(str(n))


ret = order_count(N)
i = 1
while i**2 <= N:
    if N % i == 0:
        ret = min(ret, max(order_count(i), order_count(N // i)))
    i += 1
print(ret)


"""
とりあえず素因数分解
それぞれをAとBに振り分けて、
最大桁が小さくなるように割り振る

10**10
大きい、O(N)でもだめ
logNでできる方法を探す必要がある
sqrt(N)ぐらいな感じする

最も因数が多くなるのは？
2だけで構成されてるとき、2^34ぐらい？
とすると、高々それぐらいの因数しか存在しない

さすがにbit全探索するにはおおきい

ただ、どっかでかけても改善しなくなるので枝切りしていい
基準は>10**6
34* 10**6まで最大検証すればいい、勝った

はい1WA
1の時の考慮が抜けていた、最小値ぐらいは試すべき

解説後
そもそもi**2<Nの範囲のiのどれかは当たるじゃん

"""
