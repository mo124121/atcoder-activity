#!/usr/bin/env python3
from itertools import product
import sys

MOD = 1000000007  # type: int
FULL = 2**60 - 1


def solve(
    N: int, Q: int, x: "List[int]", y: "List[int]", z: "List[int]", w: "List[int]"
):
    ret = 1
    for i in range(60):
        r = 0
        for p in product((1, 0), repeat=N):
            flag = True
            for q in range(Q):
                xf = p[x[q] - 1]
                yf = p[y[q] - 1]
                zf = p[z[q] - 1]
                if (w[q] >> i & 1) != (xf | yf | zf):
                    flag = False
                    break
            if flag:
                r += 1
        ret = ret * r % MOD
    print(ret)

    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    x = [int()] * (Q)  # type: "List[int]"
    y = [int()] * (Q)  # type: "List[int]"
    z = [int()] * (Q)  # type: "List[int]"
    w = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        x[i] = int(next(tokens))
        y[i] = int(next(tokens))
        z[i] = int(next(tokens))
        w[i] = int(next(tokens))
    solve(N, Q, x, y, z, w)


if __name__ == "__main__":
    main()


"""
考察
N<12 小さい！
Q<50

bit演算で制約をおいていくイメージ？
問題はわかるが方針が立たない
いったん手を動かす
in
4 2
1 2 3 50
2 3 4 45

50=0x110010
45=0x101101

各数のbit桁に対して制約をかけていく
dp[数列の番号][bit桁]=とれるパターン
ちょっと違う？

初期化は全て2 0or1
制約が0のとき:orで0が来たら0しかとれないので1
制約が1のとき:状況次第。どれかは1にならなきゃいけない　それぞれの数だけでは自由に決められない
            全部1=1、2つ1=3、一つ1=3

大事な事実として、桁同士は独立しているので、
Π(各桁でとれるN個の数列パターン)
が答え

N=12なので、桁ごとに全制約みたしているかみればいいのでは？
bit数×全列挙×制約
=logW x 2^N x Q
60x2^12x50
60x4096x50
=10*6ぐらい？
"""
