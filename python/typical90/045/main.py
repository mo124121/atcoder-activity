#!/usr/bin/env python3
import sys


def solve(N: int, K: int, X: "List[int]", Y: "List[int]"):

    ds = [[0] * N for _ in range(N)]

    # 二点間の距離算出
    for i in range(N - 1):
        for j in range(i + 1, N):
            d = (X[i] - X[j]) ** 2 + (Y[i] - Y[j]) ** 2
            ds[i][j] = d
            ds[j][i] = d

    # bitが立っているグループの最大距離算出
    d_bit = [0] * (1 << N)
    for i in range(1, 1 << N):
        for j in range(N):
            for k in range(j):
                if i >> j & 1 == 1 and i >> k & 1 == 1:
                    d_bit[i] = max(d_bit[i], ds[j][k])

    INF = 10**18
    dp = [[INF] * (1 << N) for _ in range(K + 1)]
    dp[0][0] = 0

    for i in range(K):
        for j in range(1, 1 << N):
            k = j
            while k != 0:
                dp[i + 1][j] = min(dp[i + 1][j], max(dp[i][j - k], d_bit[k]))
                k = (k - 1) & j

    print(dp[K][(1 << N) - 1])
    return


# Generated by 2.12.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word

    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    X = [int()] * (N)  # type: "List[int]"
    Y = [int()] * (N)  # type: "List[int]"
    for i in range(N):
        X[i] = int(next(tokens))
        Y[i] = int(next(tokens))
    solve(N, K, X, Y)


if __name__ == "__main__":
    main()


"""
考察
k近傍法っぽい　クラスタリングや

K<N<15　小さい

問題設定を言い換えると、辺のコストが実距離で定義されたグラフ
K個の連結部分に分割して、最大のコスト辺を最小化すること

辺の数　N*(N-1)//2 全部のコストは計算できる

ヒープを使って小さいほうから接続していく？
連結部分の個数をどう計算していくか？ UF? 元が接続されていないものが接続されたとき、
連結部分の個数が減る
なんかいけそうなので実装する

違った、どれかひとつ繋がればいいわけじゃない、全部つながる必要がある
とすると、ヒープを使うなら、つながっているものがある場合は一番遠いやつを選ぶ必要がある

サイズも大きくないし、都度走査してもいいのでは
心情的に自分が所属するunionのサイズがほしい

3/21 WA
コーナーケースのような数字だけど、嘘回答に近い気もする
現在のアプローチの問題は何か？

先につないじゃいけないものをつなぐ可能性がある
X=0 K=2
0 2 4 5 7 9
これだと先に4-5がつながって、
どうしようもなくなる

最小からやると事故ってる、どうするか？

遠くのほうからつなぐ？
別につなぐのがマストじゃない

解法後
bitDP・・・だと・・・？

"""
