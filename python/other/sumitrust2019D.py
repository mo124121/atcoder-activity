N = int(input())
S = input()

dp_l = [0] * N
dp_r = [0] * N
# 左から
for i in range(1, N):
    dp_l[i] = dp_l[i - 1] | (1 << int(S[i - 1]))

# 右から
for i in range(N - 2, -1, -1):
    dp_r[i] = dp_r[i + 1] | (1 << int(S[i + 1]))

# 組み合わせ出現チェック
ret = {}
for i in range(1, N - 1):
    for l in range(10):
        for r in range(10):
            if ((dp_l[i] >> l) & 1 == 1) and ((dp_r[i] >> r) & 1 == 1):
                ret[(l, int(S[i]), r)] = True

print(len(ret))
"""
N<30000
N^2<9*10**8
大きいような小さいような、ちょっと変な数字
stringではN^2パターンはメモリに乗らない
重たいfor in range(N**2)は通らなそう


答えは最大で1000
i番目の右にある数値パターン×j番目の数字パターン×k番目の数字パターン　なんか違う


三つの数字を選ぶ話
真ん中を軸に、左右のパターンを見ていくとか？
i番目の数字の左側に現れるパターン×右側に現れるパターン
1.線形走査してある数字までに現れている数字0~9を記録
2.左の数字×まんなかi番目×右の数字　10*N*10<3*10**6　間に合いそう
AC

解説後
1000*N<3*10**7に気づいた次点で全走査したらいい
答え起点で存在の有無を走査するイメージ

"""
